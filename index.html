<!DOCTYPE html>
<html>
<head>
<title>DropMerge</title>
<style>
  body { margin: 0; padding: 0; overflow: hidden; background-color: #333; }
  canvas { display: block; margin: auto; border: 2px solid #555; background: #555; }
  .button-container {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 20px;
  }
  .control-button {
    font-size: 24px;
    padding: 10px 30px;
    cursor: pointer;
    border: 2px solid white;
    background-color: #777;
    color: white;
    border-radius: 10px;
    user-select: none;
    font-family: Arial, sans-serif;
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div class="button-container">
    <div class="control-button" id="leftButton">Left</div>
    <div class="control-button" id="rightButton">Right</div>
</div>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const leftButton = document.getElementById('leftButton');
const rightButton = document.getElementById('rightButton');

const TILE_SIZE = 60;
const BOARD_ROWS = 6;
const BOARD_COLS = 5;
const BOARD_SIZE = TILE_SIZE * BOARD_COLS;
const BOARD_X = (window.innerWidth - BOARD_SIZE) / 2;
const BOARD_Y = (window.innerHeight - TILE_SIZE * BOARD_ROWS) / 2;

let board = Array(BOARD_ROWS).fill(null).map(() => Array(BOARD_COLS).fill(0));
let currentBlock = null;
let activeCol = Math.floor(BOARD_COLS / 2);
let score = 0;
let gameOver = false;

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function drawGameElements() {
  // Draw board background and tiles
  ctx.fillStyle = '#444';
  ctx.fillRect(BOARD_X, BOARD_Y, BOARD_SIZE, TILE_SIZE * BOARD_ROWS);
  
  // Highlight active column
  ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
  ctx.fillRect(BOARD_X + activeCol * TILE_SIZE, BOARD_Y, TILE_SIZE, TILE_SIZE * BOARD_ROWS);
  
  for (let r = 0; r < BOARD_ROWS; r++) {
    for (let c = 0; c < BOARD_COLS; c++) {
      const value = board[r][c];
      if (value > 0) {
        const x = BOARD_X + c * TILE_SIZE;
        const y = BOARD_Y + r * TILE_SIZE;
        ctx.fillStyle = getColorForValue(value);
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        drawText(value, x + TILE_SIZE / 2, y + TILE_SIZE / 2, 'white', 20);
      }
    }
  }
}

function drawText(text, x, y, color, size = 24) {
  ctx.fillStyle = color;
  ctx.font = `${size}px Arial`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, x, y);
}

function getColorForValue(value) {
  const colors = {
    2: '#eee4da', 4: '#ede0c8', 8: '#f2b179', 16: '#f59563',
    32: '#f67c5f', 64: '#f65e3b', 128: '#edcf72', 256: '#edcc61',
    512: '#edc850', 1024: '#edc53f', 2048: '#edc22e'
  };
  return colors[value] || '#3c3a32';
}

function getNextAvailableRow(col) {
  for (let r = BOARD_ROWS - 1; r >= 0; r--) {
    if (board[r][col] === 0) {
      return r;
    }
  }
  return -1;
}

function generateBlock() {
  const values = [2, 4, 8];
  return {
    value: values[Math.floor(Math.random() * values.length)],
    x: BOARD_X + activeCol * TILE_SIZE + TILE_SIZE / 2,
    y: 0,
    speed: 5
  };
}

function updateGame() {
  if (gameOver) return;

  if (!currentBlock) {
    currentBlock = generateBlock();
  }

  // Block movement
  currentBlock.y += currentBlock.speed;
  const targetRow = getNextAvailableRow(activeCol);

  // Check if block has landed
  if (targetRow === -1 || currentBlock.y >= BOARD_Y + targetRow * TILE_SIZE) {
    if (targetRow === -1) {
      gameOver = true;
      return;
    }
    
    // Check for merge
    const mergeRow = targetRow + 1;
    if (mergeRow < BOARD_ROWS && board[mergeRow][activeCol] === currentBlock.value) {
      board[mergeRow][activeCol] *= 2;
      score += board[mergeRow][activeCol];
    } else {
      board[targetRow][activeCol] = currentBlock.value;
    }

    currentBlock = null;
  }
}

function drawGame() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawGameElements();

  if (currentBlock) {
    ctx.fillStyle = getColorForValue(currentBlock.value);
    ctx.fillRect(currentBlock.x - TILE_SIZE / 2, currentBlock.y - TILE_SIZE / 2, TILE_SIZE, TILE_SIZE);
    drawText(currentBlock.value, currentBlock.x, currentBlock.y, 'white', 20);
  }
  
  ctx.fillStyle = 'white';
  ctx.font = '24px Arial';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'top';
  ctx.fillText(`Score: ${score}`, canvas.width - 20, 20);
  
  if (gameOver) {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'white';
    ctx.font = '40px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 50);
    ctx.font = '24px Arial';
    ctx.fillText('Score: ' + score, canvas.width / 2, canvas.height / 2);
    ctx.fillText('try again', canvas.width / 2, canvas.height / 2 + 50);
  }
}

function gameLoop() {
  updateGame();
  drawGame();
  requestAnimationFrame(gameLoop);
}

// Player controls
function moveActiveCol(direction) {
    if (gameOver) return;
    activeCol = Math.max(0, Math.min(BOARD_COLS - 1, activeCol + direction));
    
    if (currentBlock) {
        currentBlock.x = BOARD_X + activeCol * TILE_SIZE + TILE_SIZE / 2;
    }
}

leftButton.addEventListener('mousedown', () => moveActiveCol(-1));
rightButton.addEventListener('mousedown', () => moveActiveCol(1));
leftButton.addEventListener('touchstart', (e) => { e.preventDefault(); moveActiveCol(-1); }, { passive: false });
rightButton.addEventListener('touchstart', (e) => { e.preventDefault(); moveActiveCol(1); }, { passive: false });

document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowLeft') {
    moveActiveCol(-1);
  } else if (e.key === 'ArrowRight') {
    moveActiveCol(1);
  }
});

gameLoop();
</script>
</body>
</html>
